diff --git a/hw/arm/Makefile.objs b/hw/arm/Makefile.objs
index 4c5c4ee..10245a8 100644
--- a/hw/arm/Makefile.objs
+++ b/hw/arm/Makefile.objs
@@ -2,7 +2,7 @@ obj-y += boot.o collie.o exynos4_boards.o gumstix.o highbank.o
 obj-$(CONFIG_DIGIC) += digic_boards.o
 obj-y += integratorcp.o mainstone.o musicpal.o nseries.o
 obj-y += omap_sx1.o palm.o realview.o spitz.o stellaris.o
-obj-y += tosa.o versatilepb.o vexpress.o virt.o xilinx_zynq.o z2.o
+obj-y += tosa.o versatilepb.o vexpress.o virt.o xilinx_zynq.o z2.o tiger4nsc.o
 obj-$(CONFIG_ACPI) += virt-acpi-build.o
 obj-y += netduino2.o
 obj-y += sysbus-fdt.o
diff --git a/hw/arm/host_lld.h b/hw/arm/host_lld.h
new file mode 100644
index 0000000..d80d15f
--- /dev/null
+++ b/hw/arm/host_lld.h
@@ -0,0 +1,426 @@
+//////////////////////////////////////////////////////////////////////////////////
+// host_lld.h for Cosmos+ OpenSSD
+// Copyright (c) 2016 Hanyang University ENC Lab.
+// Contributed by Yong Ho Song <yhsong@enc.hanyang.ac.kr>
+//				  Youngjin Jo <yjjo@enc.hanyang.ac.kr>
+//				  Sangjin Lee <sjlee@enc.hanyang.ac.kr>
+//				  Jaewook Kwak <jwkwak@enc.hanyang.ac.kr>
+//
+// This file is part of Cosmos+ OpenSSD.
+//
+// Cosmos+ OpenSSD is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// Cosmos+ OpenSSD is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Cosmos+ OpenSSD; see the file COPYING.
+// If not, see <http://www.gnu.org/licenses/>.
+//////////////////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////////////////
+// Company: ENC Lab. <http://enc.hanyang.ac.kr>
+// Engineer: Sangjin Lee <sjlee@enc.hanyang.ac.kr>
+//			 Jaewook Kwak <jwkwak@enc.hanyang.ac.kr>
+//
+// Project Name: Cosmos+ OpenSSD
+// Design Name: Cosmos+ Firmware
+// Module Name: NVMe Low Level Driver
+// File Name: host_lld.h
+//
+// Version: v1.1.0
+//
+// Description:
+//   - defines parameters and data structures of the NVMe low level driver
+//   - declares functions of the NVMe low level driver
+//////////////////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////////////////
+// Revision History:
+//
+// * v1.1.0
+//   - new DMA status type is added (HOST_DMA_ASSIST_STATUS)
+//	 - DMA partial done check functions are added
+//
+// * v1.0.0
+//   - First draft
+//////////////////////////////////////////////////////////////////////////////////
+
+#ifndef __HOST_LLD_H_
+#define __HOST_LLD_H_
+
+//QEMU needs relative addresses
+//#define HOST_IP_ADDR						(XPAR_NVMEHOSTCONTROLLER_0_BASEADDR)
+#define HOST_IP_ADDR						0
+
+#define DEV_IRQ_MASK_REG_ADDR				(HOST_IP_ADDR + 0x4)
+#define DEV_IRQ_CLEAR_REG_ADDR				(HOST_IP_ADDR + 0x8)
+#define DEV_IRQ_STATUS_REG_ADDR				(HOST_IP_ADDR + 0xC)
+
+#define PCIE_STATUS_REG_ADDR				(HOST_IP_ADDR + 0x100)
+#define PCIE_FUNC_REG_ADDR				(HOST_IP_ADDR + 0x104)
+
+#define NVME_STATUS_REG_ADDR				(HOST_IP_ADDR + 0x200)
+#define HOST_DMA_FIFO_CNT_REG_ADDR			(HOST_IP_ADDR + 0x204)
+#define HOST_DMA_FIFO_CNT_REG_ADDR0                     (HOST_DMA_FIFO_CNT_REG_ADDR)
+#define HOST_DMA_FIFO_CNT_REG_ADDR1                     (HOST_DMA_FIFO_CNT_REG_ADDR + 0x4)
+
+#define NVME_ADMIN_QUEUE_SET_REG_ADDR		        (HOST_IP_ADDR + 0x21C)
+#define NVME_IO_SQ_SET_REG_ADDR				(HOST_IP_ADDR + 0x220)
+#define NVME_IO_SQ_SET_REG_ADDR_END			(NVME_IO_SQ_SET_REG_ADDR + 0x40)
+#define NVME_IO_CQ_SET_REG_ADDR				(HOST_IP_ADDR + 0x260)
+#define NVME_IO_CQ_SET_REG_ADDR_END			(NVME_IO_CQ_SET_REG_ADDR + 0x40)
+
+#define NVME_CMD_FIFO_REG_ADDR				(HOST_IP_ADDR + 0x300)
+#define NVME_CPL_FIFO_REG_ADDR				(HOST_IP_ADDR + 0x304)
+#define NVME_CPL_FIFO_REG_ADDR0                         (NVME_CPL_FIFO_REG_ADDR)
+#define NVME_CPL_FIFO_REG_ADDR1                         (NVME_CPL_FIFO_REG_ADDR + 0x4)
+#define NVME_CPL_FIFO_REG_ADDR2                         (NVME_CPL_FIFO_REG_ADDR + 0x8)
+#define HOST_DMA_CMD_FIFO_REG_ADDR			(HOST_IP_ADDR + 0x310)
+#define HOST_DMA_CMD_FIFO_REG_ADDR0                     (HOST_DMA_CMD_FIFO_REG_ADDR)
+#define HOST_DMA_CMD_FIFO_REG_ADDR1                     (HOST_DMA_CMD_FIFO_REG_ADDR + 0x4)
+#define HOST_DMA_CMD_FIFO_REG_ADDR2                     (HOST_DMA_CMD_FIFO_REG_ADDR + 0x8)
+#define HOST_DMA_CMD_FIFO_REG_ADDR3                     (HOST_DMA_CMD_FIFO_REG_ADDR + 0x10)
+
+#define NVME_CMD_SRAM_ADDR				(HOST_IP_ADDR + 0x2000)
+
+
+
+#define HOST_DMA_DIRECT_TYPE				(1)
+#define HOST_DMA_AUTO_TYPE					(0)
+
+#define HOST_DMA_TX_DIRECTION				(1)
+#define HOST_DMA_RX_DIRECTION				(0)
+
+#define ONLY_CPL_TYPE						(0)
+#define AUTO_CPL_TYPE						(1)
+#define CMD_SLOT_RELEASE_TYPE				(2)
+
+// NOTE Those are all unions the higher uint32_t triggers the cmd
+// NOTE Need to force 4byte R/W
+
+#pragma pack(push, 1)
+
+
+
+//offset: 0x4, 0x8, 0xc, size:4
+typedef struct _DEV_IRQ_REG
+{
+	union {
+		unsigned int dword;
+		struct {
+			unsigned int pcieLink			:1;
+			unsigned int busMaster			:1;
+			unsigned int pcieIrq			:1;
+			unsigned int pcieMsi			:1;
+			unsigned int pcieMsix			:1;
+			unsigned int nvmeCcEn			:1;
+			unsigned int nvmeCcShn			:1;
+			unsigned int mAxiWriteErr		:1;
+			unsigned int mAxiReadErr		:1;
+			unsigned int pcieMreqErr		:1;
+			unsigned int pcieCpldErr		:1;
+			unsigned int pcieCpldLenErr		:1;
+			unsigned int reserved0			:20;
+		};
+	};
+} DEV_IRQ_REG;
+
+//offset: 0x100, size: 4
+typedef struct _PCIE_STATUS_REG
+{
+	union {
+		unsigned int dword;
+		struct {
+			unsigned int ltssm				:6;
+			unsigned int reserved0			:2;
+			unsigned int pcieLinkUp			:1;
+			unsigned int reserved1			:23;
+		};
+	};
+} PCIE_STATUS_REG;
+
+//offset: 0x104, size: 4
+typedef struct _PCIE_FUNC_REG
+{
+	union {
+		unsigned int dword;
+		struct {
+			unsigned int busMaster			:1;
+			unsigned int msiEnable			:1;
+			unsigned int msixEnable			:1;
+			unsigned int irqDisable			:1;
+			unsigned int msiVecNum			:3;
+			unsigned int reserved0			:25;
+		};
+	};
+} PCIE_FUNC_REG;
+
+//offset: 0x00000200, size: 4
+typedef struct _NVME_STATUS_REG
+{
+	union {
+		unsigned int dword;
+		struct {
+			unsigned int ccEn				:1;
+			unsigned int ccShn				:2;
+			unsigned int reserved0			:1;
+			unsigned int cstsRdy			:1;
+			unsigned int cstsShst			:2;
+			unsigned int reserved1			:25;
+		};
+	};
+} NVME_STATUS_REG;
+
+//offset: 0x00000300, size: 4
+typedef struct _NVME_CMD_FIFO_REG
+{
+	union {
+		unsigned int dword;
+		struct {
+			unsigned int qID				:4;
+			unsigned int reserved0			:4;
+			unsigned int cmdSlotTag			:7;
+			unsigned int reserved2			:1;
+			unsigned int cmdSeqNum			:8;
+			unsigned int reserved3			:7;
+			unsigned int cmdValid			:1;
+		};
+	};
+} NVME_CMD_FIFO_REG;
+
+//offset: 0x00000304, size: 12
+typedef struct _NVME_CPL_FIFO_REG
+{
+	union {
+		unsigned int dword[3];
+		struct {
+			struct 
+			{
+				unsigned int cid				:16;
+				unsigned int sqId				:4;
+				unsigned int reserved0			:12;
+			};
+
+			unsigned int specific;
+
+			unsigned short cmdSlotTag			:7;
+			unsigned short reserved1			:7;
+			unsigned short cplType				:2;
+
+			union {
+				unsigned short statusFieldWord;
+				struct 
+				{
+					unsigned short reserved0	:1;
+					unsigned short SC			:8;
+					unsigned short SCT			:3;
+					unsigned short reserved1	:2;
+					unsigned short MORE			:1;
+					unsigned short DNR			:1;
+				}statusField;
+			};
+		};
+	};
+} NVME_CPL_FIFO_REG;
+
+//offset: 0x0000021C, size: 4
+typedef struct _NVME_ADMIN_QUEUE_SET_REG
+{
+	union {
+		unsigned int dword;
+		struct {
+			unsigned int cqValid			:1;
+			unsigned int sqValid			:1;
+			unsigned int cqIrqEn			:1;
+			unsigned int reserved0			:29;
+		};
+	};
+} NVME_ADMIN_QUEUE_SET_REG;
+
+//offset: 0x00000220, size: 8
+typedef struct _NVME_IO_SQ_SET_REG
+{
+	union {
+		unsigned int dword[2];
+		struct {
+			unsigned int pcieBaseAddrL;
+			unsigned int pcieBaseAddrH		:4;
+			unsigned int reserved0			:11;
+			unsigned int valid				:1;
+			unsigned int cqVector			:4;
+			unsigned int reserved1			:4;
+			unsigned int sqSize				:8;
+		};
+	};
+} NVME_IO_SQ_SET_REG;
+/* 0x40 (64) vector of 8 */
+
+
+//offset: 0x00000260, size: 8
+typedef struct _NVME_IO_CQ_SET_REG
+{
+	union {
+		unsigned int dword[2];
+		struct {
+			unsigned int pcieBaseAddrL;
+			unsigned int pcieBaseAddrH		:4;
+			unsigned int reserved0			:11;
+			unsigned int valid				:1;
+			unsigned int irqVector			:3;
+			unsigned int irqEn				:1;
+			unsigned int reserved1			:4;
+			unsigned int cqSize				:8;
+		};
+	};
+} NVME_IO_CQ_SET_REG;
+/* 0x40 (64) vector of 8 */
+
+//offset: 0x00000204, size: 4
+typedef struct _HOST_DMA_FIFO_CNT_REG
+{
+	union {
+		unsigned int dword;
+		struct 
+		{
+			unsigned char directDmaRx;
+			unsigned char directDmaTx;
+			unsigned char autoDmaRx;
+			unsigned char autoDmaTx;
+		};
+	};
+} HOST_DMA_FIFO_CNT_REG;
+
+//offset: 0x0000030C, size: 16
+typedef struct _HOST_DMA_CMD_FIFO_REG
+{
+	union {
+		unsigned int dword[4];
+		struct 
+		{
+			unsigned int devAddr;
+			unsigned int pcieAddrH;
+			unsigned int pcieAddrL;			
+			struct 
+			{
+				unsigned int dmaLen				:13;
+				unsigned int reserved0			:1;
+				unsigned int cmd4KBOffset		:9;
+				unsigned int cmdSlotTag			:7;
+				unsigned int dmaDirection		:1;
+				unsigned int dmaType			:1;
+			};
+		};
+	};
+} HOST_DMA_CMD_FIFO_REG;
+
+//offset: 0x00002000, size: 64 * 128 = 8192
+typedef struct _NVME_CMD_SRAM
+{
+	unsigned int dword[128][16];
+} NVME_CMD_SRAM;
+
+//#define NVME_DEV_SIZE ((NVME_CMD_SRAM_ADDR) + (128 * 16 * sizeof(unsigned int)))
+#define NVME_DEV_SIZE ((NVME_CMD_SRAM_ADDR) + sizeof(NVME_CMD_SRAM))
+
+typedef struct _CONTROLLER
+{
+        unsigned int pad_0[1];
+        DEV_IRQ_REG dev_irq_mask_reg;
+        DEV_IRQ_REG dev_irq_clear_reg;
+        DEV_IRQ_REG dev_irq_status_reg;
+        unsigned int pad_1[(0x100 - 0x10)];
+        PCIE_STATUS_REG pcie_status_reg;
+        PCIE_FUNC_REG pcie_func_reg;
+        unsigned int pad_2[(0x200 - 0x108)];
+        NVME_STATUS_REG nvme_status_reg;
+        HOST_DMA_FIFO_CNT_REG host_dma_fifo_cnt_reg;
+        unsigned int pad_3[(0x21c - 0x208)];
+        NVME_ADMIN_QUEUE_SET_REG nvme_admin_queue_set_reg;
+        NVME_IO_SQ_SET_REG nvme_io_sq_set_reg[8];
+        NVME_IO_CQ_SET_REG nvme_io_cq_set_reg[8];
+        unsigned int pad_4[(0x300 - 0x280)];
+        NVME_CMD_FIFO_REG nvme_cmd_fifo_reg;
+        NVME_CPL_FIFO_REG nvme_cpl_fifo_reg;
+        HOST_DMA_CMD_FIFO_REG host_dma_cmd_fifo_reg;
+        unsigned int pad_5[(0x2000 - 0x320)];
+        NVME_CMD_SRAM nvme_cmd_sram;
+} CONTROLLER;
+
+
+
+#pragma pack(pop)
+
+// Globals 
+
+typedef struct _HOST_DMA_STATUS
+{
+	HOST_DMA_FIFO_CNT_REG fifoHead;
+	HOST_DMA_FIFO_CNT_REG fifoTail;
+	unsigned int directDmaTxCnt;
+	unsigned int directDmaRxCnt;
+	unsigned int autoDmaTxCnt;
+	unsigned int autoDmaRxCnt;
+} HOST_DMA_STATUS;
+
+
+typedef struct _HOST_DMA_ASSIST_STATUS
+{
+	unsigned int autoDmaTxOverFlowCnt;
+	unsigned int autoDmaRxOverFlowCnt;
+} HOST_DMA_ASSIST_STATUS;
+
+void dev_irq_init();
+
+void dev_irq_handler();
+
+unsigned int check_nvme_cc_en();
+
+void set_nvme_csts_rdy();
+
+void set_nvme_csts_shst(unsigned int shst);
+
+void set_nvme_admin_queue(unsigned int sqValid, unsigned int cqValid, unsigned int cqIrqEn);
+
+unsigned int get_nvme_cmd(unsigned short *qID, unsigned short *cmdSlotTag, unsigned int *cmdSeqNum, unsigned int *cmdDword);
+
+void set_auto_nvme_cpl(unsigned int cmdSlotTag, unsigned int specific, unsigned int statusFieldWord);
+
+void set_nvme_slot_release(unsigned int cmdSlotTag);
+
+void set_nvme_cpl(unsigned int sqId, unsigned int cid, unsigned int specific, unsigned int statusFieldWord);
+
+void set_io_sq(unsigned int ioSqIdx, unsigned int valid, unsigned int cqVector, unsigned int qSzie, unsigned int pcieBaseAddrL, unsigned int pcieBaseAddrH);
+
+void set_io_cq(unsigned int ioCqIdx, unsigned int valid, unsigned int irqEn, unsigned int irqVector, unsigned int qSzie, unsigned int pcieBaseAddrL, unsigned int pcieBaseAddrH);
+
+void set_direct_tx_dma(unsigned int devAddr, unsigned int pcieAddrH, unsigned int pcieAddrL, unsigned int len);
+
+void set_direct_rx_dma(unsigned int devAddr, unsigned int pcieAddrH, unsigned int pcieAddrL, unsigned int len);
+
+void set_auto_tx_dma(unsigned int cmdSlotTag, unsigned int cmd4KBOffset, unsigned int devAddr);
+
+void set_auto_rx_dma(unsigned int cmdSlotTag, unsigned int cmd4KBOffset, unsigned int devAddr);
+
+void check_direct_tx_dma_done();
+
+void check_direct_rx_dma_done();
+
+void check_auto_tx_dma_done();
+
+void check_auto_rx_dma_done();
+
+unsigned int check_auto_tx_dma_partial_done(unsigned int tailIndex, unsigned int tailAssistIndex);
+
+unsigned int check_auto_rx_dma_partial_done(unsigned int tailIndex, unsigned int tailAssistIndex);
+
+extern HOST_DMA_STATUS g_hostDmaStatus;
+extern HOST_DMA_ASSIST_STATUS g_hostDmaAssistStatus;
+
+
+#endif	//__HOST_LLD_H_
diff --git a/hw/arm/nvme_dev.c b/hw/arm/nvme_dev.c
new file mode 100644
index 0000000..b9d8123
--- /dev/null
+++ b/hw/arm/nvme_dev.c
@@ -0,0 +1,841 @@
+/*
+ * Antonio Barbalace,  2017
+ *
+ * Most of this file originates from the host_dll source code of Cosmos+
+ */
+
+/**
+ * Usage: add options:
+ *      -drive file=<file>,if=none,id=<drive_id> 
+ *      -device nvme_dev,drive=<drive_id>,ways=8,
+ *
+ */
+
+/*#include "hw/sysbus.h"
+#include "hw/devices.h"
+#include "hw/flash.h"
+#include "sysemu/blockdev.h"
+*/
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "qemu/log.h"
+#include "qemu/error-report.h"
+
+#include "hw/qdev.h"
+#include "hw/block/block.h"
+#include "hw/hw.h"
+#include "hw/sysbus.h"
+//#include "hw/block/flash.h"
+//#include "qapi/error.h"
+//#include "qapi/visitor.h"
+#include "sysemu/sysemu.h"
+#include "sysemu/block-backend.h"
+#include "sysemu/dma.h"
+
+//the following contains the main data structures from the Cosmos FPGA NVMe implementation (includes offsets)
+#include "host_lld.h"
+
+//=============================================================================
+// COMMANDS
+//=============================================================================
+
+#define V2FCommand_NOP 0
+#define V2FCommand_Reset 1
+#define V2FCommand_SetFeatures 6
+#define V2FCommand_GetFeatures 46
+#define V2FCommand_ReadPageTrigger 13
+#define V2FCommand_ReadPageTransfer 18
+#define V2FCommand_ProgramPage 28
+#define V2FCommand_BlockErase 37
+#define V2FCommand_StatusCheck 41
+#define V2FCommand_ReadPageTransferRaw 55
+
+
+struct _NVMe_DEVState;
+
+//cmd queue data structure
+/*typedef struct nvme_devRequest {
+    struct _NVMe_DEVState * state;
+    BlockAcctCookie cookie;
+
+    BlockAIOCB*     aiocb;
+    uint32_t        cmdSelect;
+    uint32_t        rowAddress;
+    uint32_t        waySelection;
+    uint32_t        completionAddress;
+    uint32_t        errorCountAddress;   
+
+    void*           erased_block;
+    
+    uint32_t        has_qsg;
+    QEMUSGList      qsg;
+    QEMUIOVector    iov;
+    QTAILQ_ENTRY(nvme_devRequest) entry;
+} nvme_devRequest;
+*/
+
+//=============================================================================
+// STATE
+//=============================================================================
+
+#define TYPE_NVME_DEV "nvme_dev"
+
+typedef struct _NVMe_DEVState {
+    /*< private >*/
+    SysBusDevice parent;
+
+    /*< public >*/
+    MemoryRegion mmio;
+    
+    /*< public >*/
+//    BlockAcctStats acct; //NOTE that a block already includes stats
+    
+    /*
+    qemu_irq irq;
+    DeviceState *flash;
+
+    // DMA hardware handshake
+    qemu_irq req;
+    */
+    SysBusDevice * sbd;
+
+// START TODO    
+    uint8_t  manf_id, chip_id;
+    uint64_t physical_address;
+
+    //nvme_devRequest * io_req; //can be optimized by creating a free list
+    QTAILQ_HEAD(req_list, nvme_devRequest) req_list; // requests waiting for completion
+
+// END TODO
+
+    /* HW registers */
+    uint32_t dev_irq_reg;
+    uint32_t pcie_status_reg;
+    uint32_t pcie_func_reg;
+      
+    uint32_t nvme_status_reg;
+    uint32_t nvme_cmd_fifo_reg;
+    uint32_t nvme_admin_queue_set_reg;
+    
+    uint32_t nvme_cpl_fifo_reg[3];
+    uint32_t nvme_io_sq_set_reg[8][2]; // TODO this is a vector 
+    uint32_t nvme_io_cq_set_reg[8][2]; // TODO this is a vector
+    
+    uint32_t host_dma_fifo_cnt_reg[2];
+    uint32_t host_dma_cmd_fifo_reg[4];
+    
+    uint32_t nvme_cmd_sram[128][16]; // TODO this can be done with host_memory like in the ivshmem
+} NVMe_DEVState;
+
+#define NVMe_DEV(obj) \
+    OBJECT_CHECK(NVMe_DEVState, obj, TYPE_NVME_DEV)
+
+static void nvme_dev_completion(void *opaque, int ret)    
+{
+    nvme_devRequest *req = opaque;
+    NVMe_DEVState *s = req->state;
+    
+    //Note that this is writing up to 11bytes of ECC of some other kind of error check struct errorInfoArray
+    uint32_t error[ERROR_INFO_NUM] = {~0x00, ~0x00}; // 0xffffffff means no error
+    uint32_t completion = 0x1; // status completed
+    completion |= 0x60 << 1; // done
+    
+    if (ret <0) { // case of failure
+        completion |= 0x03 << 1; // failure
+        block_acct_failed(blk_get_stats(s->conf.blk), &req->cookie); //statistics
+    }
+    else { // case of everything went well
+        block_acct_done(blk_get_stats(s->conf.blk), &req->cookie); //statistics
+    }
+    
+    QTAILQ_REMOVE(&(s->req_list), req, entry);
+    
+    switch (req->cmdSelect) {
+        case V2FCommand_ReadPageTransferRaw:
+        case V2FCommand_ReadPageTransfer:
+        case V2FCommand_ProgramPage: {
+            cpu_physical_memory_write(req->completionAddress, &completion, sizeof(completion));
+            if ( (req->cmdSelect == V2FCommand_ReadPageTransfer) ||
+                 (req->cmdSelect == V2FCommand_ProgramPage) )
+                cpu_physical_memory_write(req->errorCountAddress, error, sizeof(error));
+    
+            if (req->has_qsg)
+                qemu_sglist_destroy(&(req->qsg));
+            
+            qemu_log_mask(LOG_TRACE,
+                "nvme_dev_completion: %lx Read/Program ret %d comp @ %lx error @ %lx\n", 
+                s->physical_address, ret, (long unsigned )req->completionAddress, (long unsigned)req->errorCountAddress);
+            break;
+        }
+        case V2FCommand_BlockErase: {
+            if (!(req->has_qsg))
+                qemu_iovec_destroy(&(req->iov));
+            if (req->erased_block)
+                g_free(req->erased_block);
+
+            // TODO how to handle the error ??? because we cannot write anywhere with the erase command ...
+            
+            qemu_log_mask(LOG_TRACE,
+                "nvme_dev_completion: %lx Erase ret %d comp @ %lx error @ %lx way %d @ 0x%x req@%lx\n", 
+                s->physical_address, ret, (long unsigned )req->completionAddress, (long unsigned)req->errorCountAddress, (unsigned) req->waySelection, (unsigned) req->rowAddress, (unsigned long)req);
+            break;
+        }
+        default:
+            qemu_log_mask(LOG_TRACE,
+                "nvme_dev_completion: %lx ILLEGAL COMMAND %d\n", 
+                s->physical_address, req->cmdSelect);
+    }
+    
+    g_free(req);
+}    
+    
+static void nvme_dev_command(NVMe_DEVState *s, uint32_t cmd)
+{
+    int file_align = 1;
+
+    switch (cmd) {
+        /* StatusCheck command
+         * completionAddress register contains the physical address on which to write the status
+         * the completion status is an integer
+         * 
+         * NOT CLEAR: what does this mean when there is no active command?
+         */
+        case V2FCommand_StatusCheck: {
+            nvme_devRequest *p = 0, *q = 0;
+            uint32_t completion =0;
+            int stats =0, found =0;
+            
+            //completion |= 0x03 << 1; // failure -- there cannot be any failure here
+           
+           //the algorithm is the following: I can find anything on the list with the same completion address I either don't do anything or write just 0x1
+            //I cannot find anything on the list, in that case I write completion done
+            
+            QTAILQ_FOREACH_SAFE(p, &(s->req_list), entry, q) {
+                if ( (p->waySelection == s->waySelection) &&
+                     (p->cmdSelect == V2FCommand_BlockErase) ) {
+                            completion = 0x1; // status completed
+                            cpu_physical_memory_write(s->completionAddress, &completion, sizeof(completion));
+                            found++;
+                    break;
+                }
+                
+                if ( (p->completionAddress == s->completionAddress) &&
+                     (p->waySelection == s->waySelection) ) {
+                            found++;
+                    break;
+                }
+                stats++;
+            }
+            
+            if (found == 0) {
+                    completion = 0x1; // status completed
+                    completion |= 0x60 << 1; // done
+                    cpu_physical_memory_write(s->completionAddress, &completion, sizeof(completion));
+            }                
+            
+            qemu_log_mask(LOG_TRACE,
+                "nvme_dev_command: %lx StatusCheck rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x completion %x (0x%x) stats %d\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection, s->completionAddress, completion, stats);
+
+            break;
+        }
+        /* ReadPageTransfer command
+         * OUTPUTs
+         * completionAddress reguster contains the physical address on which to write the status
+         * the completion status is an integer (unit32_t)
+         * the errorInfo is also an integer (uint32_t)
+         * NEED TO WRITE THE PAGE IN dataAddress PAGE_SIZE 16384 //16KB
+         * NEED TO WRITE THE PAGE IN spareDataAddress SPARE_SIZE 256
+         * INPUTs
+         * way
+         * rowAddress
+         * pageDataBuffer -> dataAddress
+         * spareDataBuffer -> spareDataAddress
+         */        
+        case V2FCommand_ReadPageTransferRaw:
+        case V2FCommand_ReadPageTransfer: {
+            nvme_devRequest * req = g_malloc0(sizeof(nvme_devRequest));
+            long file_offset = 0;
+            //enum BlockAcctType acct = is_write ? BLOCK_ACCT_WRITE : BLOCK_ACCT_READ;
+
+            memset(req, 0, sizeof(nvme_devRequest));
+            req->state = s;
+            req->cmdSelect = cmd; //supports ReadPageTransfer and ReadPageTransferRaw
+            req->completionAddress = s->completionAddress;
+            req->errorCountAddress = (cmd == V2FCommand_ReadPageTransfer) ? s->errorCountAddress : ~0;
+            req->waySelection = s->waySelection;
+            QTAILQ_INSERT_TAIL(&(s->req_list), req, entry); //enqueue in the list of completions
+            
+            qemu_sglist_init(&(req->qsg), DEVICE(s), 2, &address_space_memory); // rem to destroy this TODO TODO TODO            
+            if (cmd == V2FCommand_ReadPageTransfer) {
+                qemu_sglist_add(&(req->qsg), s->dataAddress, PAGE_SIZE); //data
+                qemu_sglist_add(&(req->qsg), s->spareAddress, SPARE_SIZE); //spare
+            }
+            else {
+               qemu_sglist_add(&(req->qsg), s->dataAddress, (PAGE_SIZE + SPARE_SIZE) ); //data + spare
+            }
+            req->has_qsg =1;
+            dma_acct_start(s->conf.blk, &(req->cookie), &(req->qsg), BLOCK_ACCT_READ);
+            
+            file_offset = rowAddress_get_linear(s->rowAddress) * (PAGE_SIZE + SPARE_SIZE) * s->waySelection;
+          
+            req->aiocb = dma_blk_read(s->conf.blk, &(req->qsg), 
+                         file_offset, file_align, 
+                         nvme_dev_completion, req); //opaque is a void pointer
+            
+            //qemu_log_mask(LOG_GUEST_ERROR,
+            qemu_log_mask(LOG_TRACE,
+                "nvme_dev_command: %lx %s rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x  completion %x\n", 
+                s->physical_address, 
+                (cmd == V2FCommand_ReadPageTransfer) ? "ReadPageTransfer" : (cmd == V2FCommand_ReadPageTransferRaw) ? "ReadPageTransferRaw" : "ReadPageTransferXXX",
+                s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection, s->completionAddress);           
+            
+            break;
+        }
+        case V2FCommand_ProgramPage:{
+            nvme_devRequest * req = g_malloc0(sizeof(nvme_devRequest));
+            long file_offset = 0; 
+
+            memset(req, 0, sizeof(nvme_devRequest));
+            req->state = s;
+            req->cmdSelect = V2FCommand_ProgramPage;
+            req->completionAddress = s->completionAddress;
+            req->errorCountAddress = s->errorCountAddress;
+            req->waySelection = s->waySelection;
+            QTAILQ_INSERT_TAIL(&(s->req_list), req, entry); //enqueue in the list of completions
+            
+            qemu_sglist_init(&(req->qsg), DEVICE(s), 2, &address_space_memory); // rem to destroy this TODO TODO TODO            
+            qemu_sglist_add(&(req->qsg), s->dataAddress, PAGE_SIZE); //data
+            qemu_sglist_add(&(req->qsg), s->spareAddress, SPARE_SIZE); //spare
+            req->has_qsg =1;
+            dma_acct_start(s->conf.blk, &(req->cookie), &(req->qsg), BLOCK_ACCT_WRITE);
+            
+            file_offset = rowAddress_get_linear(s->rowAddress) * (PAGE_SIZE + SPARE_SIZE) * s->waySelection;
+            
+            req->aiocb = dma_blk_write(s->conf.blk, &(req->qsg), 
+                         file_offset, file_align, 
+                         nvme_dev_completion, req); //opaque is a void pointer          
+            
+            //qemu_log_mask(LOG_GUEST_ERROR,
+            qemu_log_mask(LOG_TRACE,
+                "nvme_dev_command: %lx ProgramPage rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x completion %x\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection, s->completionAddress);           
+            
+            break;
+        }   
+        
+        /*
+         * there is no dataAddress or spareAddress passed to this command, no completion either ...
+         * ONLY 
+         *  -- way
+         *  -- rowAddress
+         */
+        case V2FCommand_BlockErase:{
+            nvme_devRequest * req = g_malloc0(sizeof(nvme_devRequest));
+            
+            void * erased_block = g_malloc0(PAGE_SIZE + SPARE_SIZE); // move this as a global or per instance variable
+            long file_offset = 0; size_t size = 0; //, _size=0;
+            int i;
+            
+            if (erased_block)
+                memset(erased_block, (~0), (PAGE_SIZE + SPARE_SIZE)); // TODO ERASE THIS IN THE COMPLETION
+
+            req->erased_block = erased_block;
+
+            memset(req, 0, sizeof(nvme_devRequest));
+            req->state = s;
+            req->cmdSelect = V2FCommand_BlockErase;
+            req->completionAddress = ~0;
+            req->errorCountAddress = ~0;
+            req->waySelection = s->waySelection;
+            QTAILQ_INSERT_TAIL(&(s->req_list), req, entry); //enqueue in the list of completions
+
+            //CREATE AN IOVEC list this is because we only know host address -- again, for performance this can be created once at init and being used at runtime multiple times 
+            qemu_iovec_init(&(req->iov), PAGE_NUM_PER_BLOCK);
+            for (i=0; i< PAGE_NUM_PER_BLOCK; i++)
+                qemu_iovec_add(&(req->iov), erased_block, (PAGE_SIZE + SPARE_SIZE));
+            // for the same reason accounting cannot be done with the dma_* APIs
+            block_acct_start(blk_get_stats(s->conf.blk), &(req->cookie),
+                           size = iov_size((req->iov.iov), PAGE_NUM_PER_BLOCK), BLOCK_ACCT_WRITE);
+                            //_size = req->iov.size;
+            
+            file_offset = rowAddress_get_linear(s->rowAddress) * (PAGE_SIZE + SPARE_SIZE) * s->waySelection;
+            req->rowAddress = file_offset;
+            
+            req->aiocb = blk_aio_pwritev(s->conf.blk, file_offset, &(req->iov), 0, nvme_dev_completion, req);           
+            
+            qemu_log_mask(LOG_TRACE,
+                "nvme_dev_command: %lx BlockErase rowAddr %x (%x) userData %x??? dataAddr %x??? spareAddr %x??? waySel %x completion %x??? (size: %ld) req@%lx\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection, s->completionAddress, (unsigned long) size, (unsigned long) req);
+            break;
+        }
+        /*case V2FCommand_NOP: {
+            //qemu_log_mask(LOG_GUEST_ERROR,
+            qemu_log_mask(LOG_TRACE,
+                "nvme_dev_command: %lx NOP rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x ERROR\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection);           
+            break;
+        }
+        case V2FCommand_Reset: {
+            //qemu_log_mask(LOG_GUEST_ERROR,
+            qemu_log_mask(LOG_TRACE,
+                "nvme_dev_command: %lx Reset rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x ERROR\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection);           
+            break;
+        }
+        case V2FCommand_SetFeatures: {
+            //qemu_log_mask(LOG_GUEST_ERROR,
+            qemu_log_mask(LOG_TRACE,
+                "nvme_dev_command: %lx SetFeatures rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x ERROR\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection);           
+            break;
+        }
+        case V2FCommand_GetFeatures: {
+            //qemu_log_mask(LOG_GUEST_ERROR,
+            qemu_log_mask(LOG_TRACE,
+                "nvme_dev_command: %lx GetFeatures rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x ERROR\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection);           
+            break;
+        }
+        case V2FCommand_ReadPageTrigger: {
+            //qemu_log_mask(LOG_GUEST_ERROR,
+            qemu_log_mask(LOG_TRACE,
+                "nvme_dev_command: %lx ReadPageTrigger rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x ERROR\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection);           
+            break;
+        }*/
+        case V2FCommand_NOP:
+        case V2FCommand_Reset:
+        case V2FCommand_SetFeatures:
+        case V2FCommand_GetFeatures:
+        case V2FCommand_ReadPageTrigger:
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR,
+            //qemu_log_mask(LOG_TRACE,
+                "nvme_dev_command: undefined command %x ERROR\n", (unsigned int)cmd);    
+        break;
+    }
+}
+    
+/*
+ * this function returns the result of the read
+ */    
+static uint64_t
+nvme_dev_mem_read(void *opaque, hwaddr addr, unsigned size)
+{
+    uint32_t ret = 0;
+    NVMe_DEVState *s = NVMe_DEV(opaque); 
+
+    /* TODO the following can be avoided */
+    if ( (addr >= NVME_CMD_SRAM_ADDR) && (addr < NVME_DEV_SIZE) ) {
+        uint32_t *ptr = s->nvme_cmd_sram;
+        ret = ptr[(addr - NVME_CMD_SRAM_ADDR)/sizeof(uint32_t)];
+        return ret;
+    }    
+    
+    /* SQ set registers array */
+    if ( (addr >= NVME_IO_SQ_SET_REG_ADDR) && (addr < NVME_IO_SQ_SET_REG_ADDR_END) ) {
+        uint32_t *ptr = s->nvme_io_sq_set_reg;
+        ret = ptr[(addr - NVME_IO_SQ_SET_REG_ADDR)/sizeof(uint32_t)];
+        return ret;
+    }
+
+    /* CQ set registers array */
+    if ( (addr >= NVME_IO_CQ_SET_REG_ADDR) && (addr < NVME_IO_CQ_SET_REG_ADDR_END) ) {
+        uint32_t *ptr = s->nvme_io_cq_set_reg;
+        ret = ptr[(addr - NVME_IO_CQ_SET_REG_ADDR)/sizeof(uint32_t)];
+        return ret;
+    }
+
+    switch (addr) {
+        case DEV_IRQ_MASK_REG_ADDR: 
+            //TODO this is a write instruction, cannot be handled here, no action
+            break;
+        case DEV_IRQ_CLEAR_REG_ADDR:
+            //TODO this is a write instruction, cannot be handled here, no action
+            break;
+        case DEV_IRQ_STATUS_REG_ADDR:
+            ret = s->dev_irq_reg;
+            break;
+        case PCIE_STATUS_REG_ADDR:
+            ret = s->pcie_status_reg;
+            break;
+        case PCIE_FUNC_REG_ADDR:
+            ret = s->pcie_func_reg;
+            break;
+        case NVME_STATUS_REG_ADDR:
+            ret = s->nvme_status_reg;
+            break;
+        case NVME_CMD_FIFO_REG_ADDR:
+            ret = s->nvme_cmd_fifo_reg;
+            break;
+        case NVME_ADMIN_QUEUE_SET_REG_ADDR:
+            ret = s->nvme_admin_queue_set_reg;
+            break;
+            
+        case NVME_CPL_FIFO_REG_ADDR0:
+            ret = s->nvme_cpl_fifo_reg[0];
+            break;
+        case NVME_CPL_FIFO_REG_ADDR1:
+            ret = s->nvme_cpl_fifo_reg[1];
+            break;
+        case NVME_CPL_FIFO_REG_ADDR2:
+            ret = s->nvme_cpl_fifo_reg[2];
+            break;
+
+        case HOST_DMA_FIFO_CNT_REG_ADDR0:
+            ret = s->host_dma_fifo_cnt_reg[0];
+            break;
+        case HOST_DMA_FIFO_CNT_REG_ADDR1:            
+            ret = s->host_dma_fifo_cnt_reg[1];
+            break;
+            
+        case HOST_DMA_CMD_FIFO_REG_ADDR0:
+            ret = s->host_dma_cmd_fifo_reg[0];
+            break;
+        case HOST_DMA_CMD_FIFO_REG_ADDR1:
+            ret = s->host_dma_cmd_fifo_reg[1];
+            break;
+        case HOST_DMA_CMD_FIFO_REG_ADDR2:
+            ret = s->host_dma_cmd_fifo_reg[2];
+            break;
+        case HOST_DMA_CMD_FIFO_REG_ADDR3:
+            ret = s->host_dma_cmd_fifo_reg[3];
+            break;
+ 
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR,
+            //qemu_log_mask(LOG_TRACE,
+                //"nvme_dev_mem_read: undefined memory address@hidden %" HWADDR_PRId "\n", addr);
+                "nvme_dev_mem_read: undefined memory address@hidden %x\n", (unsigned int)addr);
+        break;
+    }
+
+    return ret;        
+}    
+
+/*
+ * this function just writes
+ */    
+static void
+nvme_dev_mem_write(void *opaque, hwaddr addr, uint64_t val, unsigned size)
+{
+    NVMe_DEVState *s = NVMe_DEV(opaque);
+    uint32_t tmp;
+    
+    /* TODO the following can be avoided */
+    if ( (addr >= NVME_CMD_SRAM_ADDR) && (addr < NVME_DEV_SIZE) ) {
+        uint32_t *ptr = s->nvme_cmd_sram;
+        ptr[(addr - NVME_CMD_SRAM_ADDR)/sizeof(uint32_t)] = (uint32_t) val;
+        return;
+    }
+    
+    /* SQ set registers array */
+    if ( (addr >= NVME_IO_SQ_SET_REG_ADDR) && (addr < NVME_IO_SQ_SET_REG_ADDR_END) ) {
+        uint32_t *ptr = s->nvme_io_sq_set_reg;
+        ptr[(addr - NVME_IO_SQ_SET_REG_ADDR)/sizeof(uint32_t)] = (uint32_t) val;
+        if ((addr & 4)) {
+            // TODO trigger command
+        /*	nvmeReg.valid = valid;
+	nvmeReg.cqVector = cqVector;
+	nvmeReg.sqSize = qSzie;
+	nvmeReg.pcieBaseAddrL = pcieBaseAddrL;
+	nvmeReg.pcieBaseAddrH = pcieBaseAddrH;
+*/  
+        }
+        return;
+    }
+
+    /* CQ set registers array */
+    if ( (addr >= NVME_IO_CQ_SET_REG_ADDR) && (addr < NVME_IO_CQ_SET_REG_ADDR_END) ) {
+        uint32_t *ptr = s->nvme_io_cq_set_reg;
+        ptr[(addr - NVME_IO_SQ_SET_REG_ADDR)/sizeof(uint32_t)] = (uint32_t) val;
+        if ((addr & 4)) {
+            // TODO trigger command
+        /*	nvmeReg.valid = valid;
+	nvmeReg.cqVector = cqVector;
+	nvmeReg.sqSize = qSzie;
+	nvmeReg.pcieBaseAddrL = pcieBaseAddrL;
+	nvmeReg.pcieBaseAddrH = pcieBaseAddrH;
+*/  
+        }
+        return;
+    }
+
+    switch (addr) {
+        case DEV_IRQ_MASK_REG_ADDR: 
+            s->dev_irq_reg |= (uint32_t) val;
+            break;
+        case DEV_IRQ_CLEAR_REG_ADDR:
+            s->dev_irq_reg &= (uint32_t) ~val;
+            break;
+        case DEV_IRQ_STATUS_REG_ADDR:
+            //TODO this is a read instruction, cannot be handled here, no action
+            break;
+        case PCIE_STATUS_REG_ADDR:
+            s->pcie_status_reg = (uint32_t) val;
+            break;
+        case PCIE_FUNC_REG_ADDR:
+            s->pcie_func_reg = (uint32_t) val;
+            break;
+        case NVME_STATUS_REG_ADDR:
+/*	nvmeReg.cstsRdy = rdy;
+	nvmeReg.cstsShst = shst;
+        */  
+            tmp = s->nvme_status_reg;
+            s->nvme_status_reg = (uint32_t) val;
+            //if (tmp != val) ACT, otherwise maybe just a trigger? TODO TODO DECISION: do the action anyway
+                
+            break;
+        case NVME_CMD_FIFO_REG_ADDR:
+            s->nvme_cmd_fifo_reg = (uint32_t) val;
+            break;
+        case NVME_ADMIN_QUEUE_SET_REG_ADDR:
+/*	nvmeReg.sqValid = sqValid;
+	nvmeReg.cqValid = cqValid;
+	nvmeReg.cqIrqEn = cqIrqEn;
+        */
+            s->nvme_admin_queue_set_reg = (uint32_t) val;
+            break;
+            
+        case NVME_CPL_FIFO_REG_ADDR0:
+            s->nvme_cpl_fifo_reg[0] = (uint32_t) val;
+            break;
+        case NVME_CPL_FIFO_REG_ADDR1:
+            s->nvme_cpl_fifo_reg[1] = (uint32_t) val;
+            break;
+        case NVME_CPL_FIFO_REG_ADDR2:
+/* 	nvmeReg.specific = specific;
+	nvmeReg.cmdSlotTag = cmdSlotTag;
+	nvmeReg.statusFieldWord = statusFieldWord;
+	nvmeReg.cplType = AUTO_CPL_TYPE;
+        
+        nvmeReg.cmdSlotTag = cmdSlotTag;
+	nvmeReg.cplType = CMD_SLOT_RELEASE_TYPE;
+        
+        nvmeReg.cid = cid;
+	nvmeReg.sqId = sqId;
+	nvmeReg.specific = specific;
+	nvmeReg.statusFieldWord = statusFieldWord;
+	nvmeReg.cplType = ONLY_CPL_TYPE;
+        
+        
+*/        
+            s->nvme_cpl_fifo_reg[2] = (uint32_t) val;
+            //TODO trigger here?
+            break;
+
+        case HOST_DMA_FIFO_CNT_REG_ADDR0:
+            //TODO this is used only in read
+            s->host_dma_fifo_cnt_reg[0] = (uint32_t) val;
+            break;
+        case HOST_DMA_FIFO_CNT_REG_ADDR1:            
+            //TODO this is used only in read
+            s->host_dma_fifo_cnt_reg[1] = (uint32_t) val;
+            break;
+            
+        case HOST_DMA_CMD_FIFO_REG_ADDR0:
+            s->host_dma_cmd_fifo_reg[0] = (uint32_t) val;
+            break;
+        case HOST_DMA_CMD_FIFO_REG_ADDR1:
+            s->host_dma_cmd_fifo_reg[1] = (uint32_t) val;
+            break;
+        case HOST_DMA_CMD_FIFO_REG_ADDR2:
+            s->host_dma_cmd_fifo_reg[2] = (uint32_t) val;
+            break;
+        case HOST_DMA_CMD_FIFO_REG_ADDR3:
+/*	hostDmaReg.devAddr = devAddr;
+	hostDmaReg.pcieAddrL = pcieAddrL;
+	hostDmaReg.pcieAddrH = pcieAddrH;
+	
+	hostDmaReg.dword[3] = 0;
+	hostDmaReg.dmaType = HOST_DMA_DIRECT_TYPE;
+	hostDmaReg.dmaDirection = HOST_DMA_TX_DIRECTION;
+	hostDmaReg.dmaLen = len;
+        
+        
+        hostDmaReg.devAddr = devAddr;
+	hostDmaReg.pcieAddrH = pcieAddrH;
+	hostDmaReg.pcieAddrL = pcieAddrL;
+
+	hostDmaReg.dword[3] = 0;
+	hostDmaReg.dmaType = HOST_DMA_DIRECT_TYPE;
+	hostDmaReg.dmaDirection = HOST_DMA_RX_DIRECTION;
+	hostDmaReg.dmaLen = len;
+        */           
+            
+            s->host_dma_cmd_fifo_reg[3] = (uint32_t) val;
+            //TODO trigger here?
+            break;
+            
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR,
+            //qemu_log_mask(LOG_TRACE,
+                //"nvme_dev_mem_read: undefined memory address@hidden %" HWADDR_PRId "\n", addr);
+                "nvme_dev_mem_read: undefined memory address@hidden %x\n", (unsigned int)addr);
+        break;
+    }
+}
+    
+    
+static const MemoryRegionOps mmio_ops = {
+    .read  = nvme_dev_mem_read,
+    .write = nvme_dev_mem_write,
+    .endianness = DEVICE_LITTLE_ENDIAN, //DEVICE_NATIVE_ENDIAN
+    .valid = {
+        .min_access_size = 4,
+        .max_access_size = 4
+    }
+};
+    
+static void nvme_dev_reset(DeviceState *ds)
+{
+    NVMe_DEVState *s = NVMe_DEV(SYS_BUS_DEVICE(ds));
+/*    Error *local_errp = NULL;
+
+    s->flash = DEVICE(object_property_get_link(OBJECT(s),
+                                               "flash",
+                                               &local_errp));
+    if (local_errp) {
+        fprintf(stderr, "ftnandc021: Unable to get flash link\n");
+        abort();
+    }
+    */
+
+    s->dev_irq_reg = 0;
+    s->pcie_status_reg;
+    s->pcie_func_reg;
+      
+    s->nvme_status_reg;
+    s->nvme_cmd_fifo_reg;
+    s->nvme_admin_queue_set_reg;
+    
+    s->nvme_cpl_fifo_reg[0] = 0; s->nvme_cpl_fifo_reg[1] = 0; s->nvme_cpl_fifo_reg[2] = 0;
+    s->nvme_io_sq_set_reg[0] = 0; s->nvme_io_sq_set_reg[1] = 0;
+    s->nvme_io_cq_set_reg[0] = 0; s->nvme_io_cq_set_reg[1] = 0;
+    
+    s->host_dma_fifo_cnt_reg[0] = 0; s->host_dma_fifo_cnt_reg[1] = 0;
+    s->host_dma_cmd_fifo_reg[0] = 0; s->host_dma_cmd_fifo_reg[1] = 0; 
+    s->host_dma_cmd_fifo_reg[1] = 0; s->host_dma_cmd_fifo_reg[3] = 0;
+    
+    memset(&(s->nvme_cmd_sram), 0, sizeof(s->nvme_cmd_sram));
+    
+    /* We can assume our GPIO outputs have been wired up now */
+//    qemu_set_irq(s->req, 0);
+
+    QTAILQ_INIT(&s->req_list);
+}
+
+static void nvme_dev_realize(DeviceState *dev, Error **errp)
+{
+    Error *local_err =NULL;
+    NVMe_DEVState *s = NVMe_DEV(dev);
+
+    sysbus_init_mmio(s->sbd, &s->mmio);
+//    sysbus_init_irq(sbd, &s->irq);
+    sysbus_mmio_map(s->sbd, 0, s->physical_address);   
+
+    /*
+    qdev_init_gpio_in(&sbd->qdev, ftnandc021_handle_ack, 1);
+    qdev_init_gpio_out(&sbd->qdev, &s->req, 1);
+    */
+    
+    qemu_log_mask(LOG_TRACE,
+                "nvme_dev_realize: s %lx phys 0x%lx ways %d\n",
+                (unsigned long) s, (unsigned long)s->physical_address, (unsigned int) s->ways );
+
+}
+
+static const VMStateDescription vmstate_nvme_dev = {
+    .name = TYPE_NVME_DEV,
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .minimum_version_id_old = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_UINT32(dev_irq_reg, NVMe_DEVState),
+        VMSTATE_UINT32(pcie_status_reg, NVMe_DEVState),
+        VMSTATE_UINT32(pcie_func_reg, NVMe_DEVState),
+        VMSTATE_UINT32(nvme_status_reg, NVMe_DEVState),
+        VMSTATE_UINT32(nvme_cmd_fifo_reg, NVMe_DEVState),
+        VMSTATE_UINT32(nvme_admin_queue_set_reg, NVMe_DEVState),
+    
+        VMSTATE_UINT32_V(nvme_cpl_fifo_reg, NVMe_DEVState, 3),
+        VMSTATE_UINT32_V(nvme_io_sq_set_reg, NVMe_DEVState, (8 * 2)),
+        VMSTATE_UINT32_V(nvme_io_cq_set_reg, NVMe_DEVState, (8 * 2)),
+        VMSTATE_UINT32_V(host_dma_fifo_cnt_reg, NVMe_DEVState, 2),
+        VMSTATE_UINT32_V(host_dma_cmd_fifo_reg, NVMe_DEVState, 4),
+        VMSTATE_UINT32_V(nvme_cmd_sram, NVMe_DEVState, (128 * 16)),
+        VMSTATE_END_OF_LIST()
+    }
+};    
+
+static void nvme_dev_instance_init(Object *obj)
+{
+    NVMe_DEVState *s = NVMe_DEV(obj);
+/* THIS IS TO LINK WITH THE FLASH DEVICES -- WE DON'T USE THIS FOR NOW
+    object_property_add_link(obj,
+                             "flash",
+                             TYPE_DEVICE,
+                             (Object **) &s->flash,
+                             NULL);
+                             */
+
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+    s->sbd =sbd;
+    
+    memory_region_init_io(&s->mmio,
+                          obj,
+                          &mmio_ops,
+                          s,
+                          TYPE_NVME_DEV,
+                          NVME_DEV_SIZE);
+}
+    
+/* TODO finish this */
+static Property nvme_dev_properties[] = {
+    DEFINE_BLOCK_PROPERTIES(NVMe_DEVState, conf),        
+    DEFINE_PROP_UINT8("ways", NVMe_DEVState, ways, WAY_NUM),
+    DEFINE_PROP_UINT64("phys", NVMe_DEVState, physical_address, V2Fmmio_ADDR),
+/*    DEFINE_PROP_STRING("serial", NvmeCtrl, serial),
+    DEFINE_PROP_DRIVE("drive", NVMe_DEVState, blk), */
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void nvme_dev_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->vmsd    = &vmstate_nvme_dev;
+    dc->reset   = nvme_dev_reset;
+    dc->realize = nvme_dev_realize;
+    dc->props = nvme_dev_properties;
+    dc->hotpluggable = true;
+    dc->user_creatable = true;
+    //dc->no_user = 1;
+}
+
+static const TypeInfo nvme_dev_info = {
+    .name          = TYPE_NVME_DEV,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(NVMe_DEVState),
+    .instance_init = nvme_dev_instance_init,
+    .class_init    = nvme_dev_class_init,
+};
+
+static void nvme_dev_register_types(void)
+{
+    type_register_static(&nvme_dev_info);
+}
+
+type_init(nvme_dev_register_types)
diff --git a/hw/arm/tiger4nsc.c b/hw/arm/tiger4nsc.c
new file mode 100644
index 0000000..3bd9514
--- /dev/null
+++ b/hw/arm/tiger4nsc.c
@@ -0,0 +1,816 @@
+/*
+ * Antonio Barbalace,  2017
+ *
+ * Most of this file originates from the fmc_driver source code of Cosmos+
+ */
+
+/**
+ * Usage: add options:
+ *      -drive file=<file>,if=none,id=<drive_id> 
+ *      -device tiger4nsc,drive=<drive_id>,ways=8,
+ *
+ */
+
+/*#include "hw/sysbus.h"
+#include "hw/devices.h"
+#include "hw/flash.h"
+#include "sysemu/blockdev.h"
+*/
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "qemu/log.h"
+#include "qemu/error-report.h"
+
+#include "hw/qdev.h"
+#include "hw/block/block.h"
+#include "hw/hw.h"
+#include "hw/sysbus.h"
+//#include "hw/block/flash.h"
+//#include "qapi/error.h"
+//#include "qapi/visitor.h"
+#include "sysemu/sysemu.h"
+#include "sysemu/block-backend.h"
+#include "sysemu/dma.h"
+
+/* configurable options */
+
+#define	WAY_NUM					8
+
+/* fixed options */
+
+// NOTE: there is a device controller per channel -- thus, this is not a configuration option
+/*
+#define	CHANNEL_NUM				2
+#define	MAX_CHANNEL_NUM	                        8
+*/
+
+#define	MAX_WAY_NUM				8
+//#define	DIE_NUM					(CHANNEL_NUM * WAY_NUM)
+
+#define V2Fmmio_SIZE 0x10000
+#define V2Fmmio_ADDR 0x43c00000
+
+//ECC error information
+#define ERROR_INFO_NUM 11
+
+#define	SECTOR_SIZE_FTL 4096	//4KB
+//#define	PAGE_SIZE       16384	//16KB
+#define	PAGE_SIZE       (16384/2)
+#define SPARE_SIZE      256	//last 8 bytes are CRC bytes
+
+#define	SLC_MODE				1
+#define	MLC_MODE				2
+#define	BIT_PER_FLASH_CELL		SLC_MODE //select SLC_MODE or MLC_MODE
+
+#define	PAGE_NUM_PER_BLOCK		(128 * BIT_PER_FLASH_CELL)
+#define	PAGE_NUM_PER_SLC_BLOCK	128
+#define	PAGE_NUM_PER_MLC_BLOCK	256
+
+#define	BLOCK_NUM_PER_LUN		512 //DRAM size doesn't enough for page mapping when MLC mode uses all blocks. If you want to use all blocks, map cache function should be implemented.
+#define	MAX_BLOCK_NUM_PER_LUN	4096
+#define LUN_NUM_PER_DIE			2
+#define	MAX_LUN_NUM_PER_DIE		2
+#define	BLOCK_SIZE_MB			((PAGE_SIZE * PAGE_NUM_PER_BLOCK) / (1024 * 1024))
+
+//LUN
+#define LUN_0_BASE_ADDR	0x00000000
+#define LUN_1_BASE_ADDR	0x00200000
+
+static inline unsigned int rowAddress_get_linear(unsigned int phy_RowAddress) {
+    unsigned int rowAddress = (phy_RowAddress < LUN_1_BASE_ADDR) ? 0 : ((128 / BIT_PER_FLASH_CELL) * BLOCK_NUM_PER_LUN);
+    if (rowAddress)
+        phy_RowAddress -= LUN_1_BASE_ADDR;
+
+// in the hope that everything will be configurable in the future    
+    if (BIT_PER_FLASH_CELL == SLC_MODE) {
+        unsigned int tempPage; //, _tempPage;
+        unsigned int tempBlock;
+        
+        if ((phy_RowAddress & (2* PAGE_NUM_PER_BLOCK -1)) == (2* PAGE_NUM_PER_BLOCK -1)) {// this supports LLSCommand_ReadRawPage, LLSCommand_ReadLsbPage, LLSCommand_WriteLsbPage
+            tempPage = (PAGE_NUM_PER_BLOCK -1);
+            tempBlock = phy_RowAddress - (2* PAGE_NUM_PER_BLOCK -1);
+            
+/*            _tempPage = ((phy_RowAddress % 2) ? ((phy_RowAddress +1) >> 1) % PAGE_NUM_PER_BLOCK : 0);
+            qemu_log_mask(LOG_TRACE,
+                "get_linear: addr %x tmpPage %x tmpBlock %x OR %x %x (%x)\n", 
+                phy_RowAddress, tempPage, tempBlock,
+                _tempPage, phy_RowAddress - ((_tempPage == 0)? 0 : ((_tempPage * 2) -1)), phy_RowAddress - ((_tempPage * 2) -1) ); */
+        }
+        else {
+            tempPage = (phy_RowAddress % 2) ? 
+                                ((phy_RowAddress +1) >> 1) % PAGE_NUM_PER_BLOCK : 0;
+            tempBlock = phy_RowAddress - ((tempPage == 0)? 0 : ((tempPage * 2) -1));
+        }
+        
+        tempBlock = tempBlock /2;
+        rowAddress += tempPage + tempBlock;
+        
+    }
+    else if (BIT_PER_FLASH_CELL == MLC_MODE) {
+        rowAddress += phy_RowAddress;
+    }
+        
+    return rowAddress;
+}
+
+typedef struct
+{
+	unsigned int cmdSelect;    //addr 0
+	unsigned int rowAddress;   //addr 4
+	unsigned int userData;     //addr 8
+	unsigned int dataAddress;  //addr 12
+        
+	unsigned int spareAddress; //addr 16 (0x10)
+	unsigned int errorCountAddress; //addr 20
+	unsigned int completionAddress; //addr 24
+	unsigned int waySelection; //addr 28
+        
+	unsigned int channelBusy;  //addr 32 (0x20)
+	unsigned int readyBusy;    //addr 36
+} V2FMCRegisters;
+
+//offsets
+#define OFFSET_cmdSelect 0
+#define OFFSET_rowAddress 4 
+#define OFFSET_userData 8
+#define OFFSET_dataAddress 12
+#define OFFSET_spareAddress 16 
+#define OFFSET_errorCountAddress 20
+#define OFFSET_completionAddress 24
+#define OFFSET_waySelection 28
+
+#define OFFSET_channelBusy 32
+//there is a ready bit per way
+#define OFFSET_readyBusy 36
+
+//commands
+#define V2FCommand_NOP 0
+#define V2FCommand_Reset 1
+#define V2FCommand_SetFeatures 6
+#define V2FCommand_GetFeatures 46
+#define V2FCommand_ReadPageTrigger 13
+#define V2FCommand_ReadPageTransfer 18
+#define V2FCommand_ProgramPage 28
+#define V2FCommand_BlockErase 37
+#define V2FCommand_StatusCheck 41
+#define V2FCommand_ReadPageTransferRaw 55
+
+struct _Tiger4nscState;
+
+typedef struct tiger4nscRequest {
+    struct _Tiger4nscState * state;
+    BlockAcctCookie cookie;
+
+    BlockAIOCB*     aiocb;
+    uint32_t        cmdSelect;
+    uint32_t        rowAddress;
+    uint32_t        waySelection;
+    uint32_t        completionAddress;
+    uint32_t        errorCountAddress;   
+
+    void*           erased_block;
+    
+    uint32_t        has_qsg;
+    QEMUSGList      qsg;
+    QEMUIOVector    iov;
+    QTAILQ_ENTRY(tiger4nscRequest) entry;
+} tiger4nscRequest;
+
+
+#define TYPE_TIGER4NSC "tiger4nsc"
+
+typedef struct _Tiger4nscState {
+    /*< private >*/
+    SysBusDevice parent;
+
+    /*< private >*/
+    BlockConf conf;
+    
+    /*< public >*/
+    MemoryRegion mmio;
+    
+    /*< public >*/
+//    BlockAcctStats acct; //NOTE that a block already includes stats
+    
+    /*
+    qemu_irq irq;
+    DeviceState *flash;
+
+    // DMA hardware handshake
+    qemu_irq req;
+    */
+    SysBusDevice * sbd;
+
+// START TODO    
+    uint8_t  manf_id, chip_id;
+    uint64_t physical_address;
+
+    
+    //Rem that channels is not an option as one controller is one channel
+    uint8_t ways;
+    uint64_t spare_size;
+    
+    uint64_t page_size;
+    uint64_t page_num_per_block;
+    
+    uint64_t lun_num_per_die;
+    
+    uint64_t block_size;
+    uint64_t block_num_per_lun;
+    uint64_t block_num_per_die;
+    uint64_t block_num_per_channel;
+    uint64_t total_size;
+    uint64_t  disk_size;
+    
+    //tiger4nscRequest * io_req; //can be optimized by creating a free list
+    QTAILQ_HEAD(req_list, tiger4nscRequest) req_list; // requests waiting for completion
+
+// END TODO
+
+    /* HW register caches */
+    uint32_t cmdSelect;
+    uint32_t rowAddress;
+    uint32_t userData;
+    uint32_t dataAddress;
+    uint32_t spareAddress;
+    uint32_t errorCountAddress;
+    uint32_t completionAddress;
+    uint32_t waySelection;
+    uint32_t channelBusy;
+    uint32_t readyBusy;    
+} Tiger4nscState;
+
+#define TIGER4NSC(obj) \
+    OBJECT_CHECK(Tiger4nscState, obj, TYPE_TIGER4NSC)
+
+static void tiger4nsc_completion(void *opaque, int ret)    
+{
+    tiger4nscRequest *req = opaque;
+    Tiger4nscState *s = req->state;
+    
+    //Note that this is writing up to 11bytes of ECC of some other kind of error check struct errorInfoArray
+    uint32_t error[ERROR_INFO_NUM] = {~0x00, ~0x00}; // 0xffffffff means no error
+    uint32_t completion = 0x1; // status completed
+    completion |= 0x60 << 1; // done
+    
+    if (ret <0) { // case of failure
+        completion |= 0x03 << 1; // failure
+        block_acct_failed(blk_get_stats(s->conf.blk), &req->cookie); //statistics
+    }
+    else { // case of everything went well
+        block_acct_done(blk_get_stats(s->conf.blk), &req->cookie); //statistics
+    }
+    
+    QTAILQ_REMOVE(&(s->req_list), req, entry);
+    
+    switch (req->cmdSelect) {
+        case V2FCommand_ReadPageTransferRaw:
+        case V2FCommand_ReadPageTransfer:
+        case V2FCommand_ProgramPage: {
+            cpu_physical_memory_write(req->completionAddress, &completion, sizeof(completion));
+            if ( (req->cmdSelect == V2FCommand_ReadPageTransfer) ||
+                 (req->cmdSelect == V2FCommand_ProgramPage) )
+                cpu_physical_memory_write(req->errorCountAddress, error, sizeof(error));
+    
+            if (req->has_qsg)
+                qemu_sglist_destroy(&(req->qsg));
+            
+            qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_completion: %lx Read/Program ret %d comp @ %lx error @ %lx\n", 
+                s->physical_address, ret, (long unsigned )req->completionAddress, (long unsigned)req->errorCountAddress);
+            break;
+        }
+        case V2FCommand_BlockErase: {
+            if (!(req->has_qsg))
+                qemu_iovec_destroy(&(req->iov));
+            if (req->erased_block)
+                g_free(req->erased_block);
+
+            // TODO how to handle the error ??? because we cannot write anywhere with the erase command ...
+            
+            qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_completion: %lx Erase ret %d comp @ %lx error @ %lx way %d @ 0x%x req@%lx\n", 
+                s->physical_address, ret, (long unsigned )req->completionAddress, (long unsigned)req->errorCountAddress, (unsigned) req->waySelection, (unsigned) req->rowAddress, (unsigned long)req);
+            break;
+        }
+        default:
+            qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_completion: %lx ILLEGAL COMMAND %d\n", 
+                s->physical_address, req->cmdSelect);
+    }
+    
+    g_free(req);
+}    
+    
+static void tiger4nsc_command(Tiger4nscState *s, uint32_t cmd)
+{
+    int file_align = 1;
+
+    switch (cmd) {
+        /* StatusCheck command
+         * completionAddress register contains the physical address on which to write the status
+         * the completion status is an integer
+         * 
+         * NOT CLEAR: what does this mean when there is no active command?
+         */
+        case V2FCommand_StatusCheck: {
+            tiger4nscRequest *p = 0, *q = 0;
+            uint32_t completion =0;
+            int stats =0, found =0;
+            
+            //completion |= 0x03 << 1; // failure -- there cannot be any failure here
+           
+           //the algorithm is the following: I can find anything on the list with the same completion address I either don't do anything or write just 0x1
+            //I cannot find anything on the list, in that case I write completion done
+            
+            QTAILQ_FOREACH_SAFE(p, &(s->req_list), entry, q) {
+                if ( (p->waySelection == s->waySelection) &&
+                     (p->cmdSelect == V2FCommand_BlockErase) ) {
+                            completion = 0x1; // status completed
+                            cpu_physical_memory_write(s->completionAddress, &completion, sizeof(completion));
+                            found++;
+                    break;
+                }
+                
+                if ( (p->completionAddress == s->completionAddress) &&
+                     (p->waySelection == s->waySelection) ) {
+                            found++;
+                    break;
+                }
+                stats++;
+            }
+            
+            if (found == 0) {
+                    completion = 0x1; // status completed
+                    completion |= 0x60 << 1; // done
+                    cpu_physical_memory_write(s->completionAddress, &completion, sizeof(completion));
+            }                
+            
+            qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_command: %lx StatusCheck rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x completion %x (0x%x) stats %d\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection, s->completionAddress, completion, stats);
+
+            break;
+        }
+        /* ReadPageTransfer command
+         * OUTPUTs
+         * completionAddress reguster contains the physical address on which to write the status
+         * the completion status is an integer (unit32_t)
+         * the errorInfo is also an integer (uint32_t)
+         * NEED TO WRITE THE PAGE IN dataAddress PAGE_SIZE 16384 //16KB
+         * NEED TO WRITE THE PAGE IN spareDataAddress SPARE_SIZE 256
+         * INPUTs
+         * way
+         * rowAddress
+         * pageDataBuffer -> dataAddress
+         * spareDataBuffer -> spareDataAddress
+         */        
+        case V2FCommand_ReadPageTransferRaw:
+        case V2FCommand_ReadPageTransfer: {
+            tiger4nscRequest * req = g_malloc0(sizeof(tiger4nscRequest));
+            long file_offset = 0;
+            //enum BlockAcctType acct = is_write ? BLOCK_ACCT_WRITE : BLOCK_ACCT_READ;
+
+            memset(req, 0, sizeof(tiger4nscRequest));
+            req->state = s;
+            req->cmdSelect = cmd; //supports ReadPageTransfer and ReadPageTransferRaw
+            req->completionAddress = s->completionAddress;
+            req->errorCountAddress = (cmd == V2FCommand_ReadPageTransfer) ? s->errorCountAddress : ~0;
+            req->waySelection = s->waySelection;
+            QTAILQ_INSERT_TAIL(&(s->req_list), req, entry); //enqueue in the list of completions
+            
+            qemu_sglist_init(&(req->qsg), DEVICE(s), 2, &address_space_memory); // rem to destroy this TODO TODO TODO            
+            if (cmd == V2FCommand_ReadPageTransfer) {
+                qemu_sglist_add(&(req->qsg), s->dataAddress, PAGE_SIZE); //data
+                qemu_sglist_add(&(req->qsg), s->spareAddress, SPARE_SIZE); //spare
+            }
+            else {
+               qemu_sglist_add(&(req->qsg), s->dataAddress, (PAGE_SIZE + SPARE_SIZE) ); //data + spare
+            }
+            req->has_qsg =1;
+            dma_acct_start(s->conf.blk, &(req->cookie), &(req->qsg), BLOCK_ACCT_READ);
+            
+            file_offset = rowAddress_get_linear(s->rowAddress) * (PAGE_SIZE + SPARE_SIZE) * s->waySelection;
+          
+            req->aiocb = dma_blk_read(s->conf.blk, &(req->qsg), 
+                         file_offset, file_align, 
+                         tiger4nsc_completion, req); //opaque is a void pointer
+            
+            //qemu_log_mask(LOG_GUEST_ERROR,
+            qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_command: %lx %s rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x  completion %x\n", 
+                s->physical_address, 
+                (cmd == V2FCommand_ReadPageTransfer) ? "ReadPageTransfer" : (cmd == V2FCommand_ReadPageTransferRaw) ? "ReadPageTransferRaw" : "ReadPageTransferXXX",
+                s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection, s->completionAddress);           
+            
+            break;
+        }
+        case V2FCommand_ProgramPage:{
+            tiger4nscRequest * req = g_malloc0(sizeof(tiger4nscRequest));
+            long file_offset = 0; 
+
+            memset(req, 0, sizeof(tiger4nscRequest));
+            req->state = s;
+            req->cmdSelect = V2FCommand_ProgramPage;
+            req->completionAddress = s->completionAddress;
+            req->errorCountAddress = s->errorCountAddress;
+            req->waySelection = s->waySelection;
+            QTAILQ_INSERT_TAIL(&(s->req_list), req, entry); //enqueue in the list of completions
+            
+            qemu_sglist_init(&(req->qsg), DEVICE(s), 2, &address_space_memory); // rem to destroy this TODO TODO TODO            
+            qemu_sglist_add(&(req->qsg), s->dataAddress, PAGE_SIZE); //data
+            qemu_sglist_add(&(req->qsg), s->spareAddress, SPARE_SIZE); //spare
+            req->has_qsg =1;
+            dma_acct_start(s->conf.blk, &(req->cookie), &(req->qsg), BLOCK_ACCT_WRITE);
+            
+            file_offset = rowAddress_get_linear(s->rowAddress) * (PAGE_SIZE + SPARE_SIZE) * s->waySelection;
+            
+            req->aiocb = dma_blk_write(s->conf.blk, &(req->qsg), 
+                         file_offset, file_align, 
+                         tiger4nsc_completion, req); //opaque is a void pointer          
+            
+            //qemu_log_mask(LOG_GUEST_ERROR,
+            qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_command: %lx ProgramPage rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x completion %x\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection, s->completionAddress);           
+            
+            break;
+        }   
+        
+        /*
+         * there is no dataAddress or spareAddress passed to this command, no completion either ...
+         * ONLY 
+         *  -- way
+         *  -- rowAddress
+         */
+        case V2FCommand_BlockErase:{
+            tiger4nscRequest * req = g_malloc0(sizeof(tiger4nscRequest));
+            
+            void * erased_block = g_malloc0(PAGE_SIZE + SPARE_SIZE); // move this as a global or per instance variable
+            long file_offset = 0; size_t size = 0; //, _size=0;
+            int i;
+            
+            if (erased_block)
+                memset(erased_block, (~0), (PAGE_SIZE + SPARE_SIZE)); // TODO ERASE THIS IN THE COMPLETION
+
+            req->erased_block = erased_block;
+
+            memset(req, 0, sizeof(tiger4nscRequest));
+            req->state = s;
+            req->cmdSelect = V2FCommand_BlockErase;
+            req->completionAddress = ~0;
+            req->errorCountAddress = ~0;
+            req->waySelection = s->waySelection;
+            QTAILQ_INSERT_TAIL(&(s->req_list), req, entry); //enqueue in the list of completions
+
+            //CREATE AN IOVEC list this is because we only know host address -- again, for performance this can be created once at init and being used at runtime multiple times 
+            qemu_iovec_init(&(req->iov), PAGE_NUM_PER_BLOCK);
+            for (i=0; i< PAGE_NUM_PER_BLOCK; i++)
+                qemu_iovec_add(&(req->iov), erased_block, (PAGE_SIZE + SPARE_SIZE));
+            // for the same reason accounting cannot be done with the dma_* APIs
+            block_acct_start(blk_get_stats(s->conf.blk), &(req->cookie),
+                           size = iov_size((req->iov.iov), PAGE_NUM_PER_BLOCK), BLOCK_ACCT_WRITE);
+                            //_size = req->iov.size;
+            
+            file_offset = rowAddress_get_linear(s->rowAddress) * (PAGE_SIZE + SPARE_SIZE) * s->waySelection;
+            req->rowAddress = file_offset;
+            
+            req->aiocb = blk_aio_pwritev(s->conf.blk, file_offset, &(req->iov), 0, tiger4nsc_completion, req);           
+            
+            qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_command: %lx BlockErase rowAddr %x (%x) userData %x??? dataAddr %x??? spareAddr %x??? waySel %x completion %x??? (size: %ld) req@%lx\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection, s->completionAddress, (unsigned long) size, (unsigned long) req);
+            break;
+        }
+        /*case V2FCommand_NOP: {
+            //qemu_log_mask(LOG_GUEST_ERROR,
+            qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_command: %lx NOP rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x ERROR\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection);           
+            break;
+        }
+        case V2FCommand_Reset: {
+            //qemu_log_mask(LOG_GUEST_ERROR,
+            qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_command: %lx Reset rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x ERROR\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection);           
+            break;
+        }
+        case V2FCommand_SetFeatures: {
+            //qemu_log_mask(LOG_GUEST_ERROR,
+            qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_command: %lx SetFeatures rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x ERROR\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection);           
+            break;
+        }
+        case V2FCommand_GetFeatures: {
+            //qemu_log_mask(LOG_GUEST_ERROR,
+            qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_command: %lx GetFeatures rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x ERROR\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection);           
+            break;
+        }
+        case V2FCommand_ReadPageTrigger: {
+            //qemu_log_mask(LOG_GUEST_ERROR,
+            qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_command: %lx ReadPageTrigger rowAddr %x (%x) userData %x dataAddr %x spareAddr %x waySel %x ERROR\n", 
+                s->physical_address, s->rowAddress, (int)rowAddress_get_linear(s->rowAddress),
+                s->userData, s->dataAddress, s->spareAddress, s->waySelection);           
+            break;
+        }*/
+        case V2FCommand_NOP:
+        case V2FCommand_Reset:
+        case V2FCommand_SetFeatures:
+        case V2FCommand_GetFeatures:
+        case V2FCommand_ReadPageTrigger:
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR,
+            //qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_command: undefined command %x ERROR\n", (unsigned int)cmd);    
+        break;
+    }
+}
+    
+/*
+ * this function returns the result of the read
+ */    
+static uint64_t
+tiger4nsc_mem_read(void *opaque, hwaddr addr, unsigned size)
+{
+    uint32_t ret = 0;
+    Tiger4nscState *s = TIGER4NSC(opaque); 
+
+    switch (addr) {
+        case OFFSET_cmdSelect: 
+            ret = s->cmdSelect;
+            break;                                    
+        case OFFSET_rowAddress:
+            ret = s->rowAddress;
+            break;                                    
+        case OFFSET_userData:
+            ret = s->userData;
+            break;                                    
+        case OFFSET_dataAddress:
+            ret = s->dataAddress;
+            break;                                    
+        case OFFSET_spareAddress:
+            ret = s->spareAddress;
+            break;                                    
+        case OFFSET_errorCountAddress:
+            ret = s->errorCountAddress;
+            break;                                    
+        case OFFSET_completionAddress:
+            ret = s->completionAddress;
+            break;                                    
+        case OFFSET_waySelection:
+            ret = s->waySelection;
+            break;                        
+        case OFFSET_channelBusy:
+            ret = s->channelBusy;
+            break;                        
+        case OFFSET_readyBusy:
+            ret = s->readyBusy;
+            break;            
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR,
+            //qemu_log_mask(LOG_TRACE,
+                //"tiger4nsc_mem_read: undefined memory address@hidden %" HWADDR_PRId "\n", addr);
+                "tiger4nsc_mem_read: undefined memory address@hidden %x\n", (unsigned int)addr);
+        break;
+    }
+
+    return ret;        
+}    
+
+/*
+ * this function just writes
+ */    
+static void
+tiger4nsc_mem_write(void *opaque, hwaddr addr, uint64_t val, unsigned size)
+{
+    //uint32_t i;
+    Tiger4nscState *s = TIGER4NSC(opaque);
+
+    switch (addr) {
+        case OFFSET_cmdSelect: 
+            s->cmdSelect = (uint32_t)val;
+            tiger4nsc_command(s, val);
+            break;
+        case OFFSET_rowAddress:
+            s->rowAddress = (uint32_t)val;
+            break;
+        case OFFSET_userData:
+            s->userData = (uint32_t)val;
+            break;
+        case OFFSET_dataAddress:
+            s->dataAddress = (uint32_t)val;
+            break;
+        case OFFSET_spareAddress:
+            s->spareAddress = (uint32_t)val;
+            break;
+        case OFFSET_errorCountAddress:
+            s->errorCountAddress = (uint32_t)val;
+            break;
+        case OFFSET_completionAddress:
+            s->completionAddress = (uint32_t)val;
+            break;
+        case OFFSET_waySelection:
+            s->waySelection = (uint32_t)val;
+            break;
+//these two in principle cannot be written            
+        case OFFSET_channelBusy:
+            //s->rowAddress = (uint32_t)val);
+            break;
+        case OFFSET_readyBusy:
+            //s->readyBusy = (uint32_t)val;
+            break;
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR,
+            //qemu_log_mask(LOG_TRACE,
+                //"tiger4nsc_mem_read: undefined memory address@hidden %" HWADDR_PRId "\n", addr);
+                "tiger4nsc_mem_read: undefined memory address@hidden %x\n", (unsigned int)addr);
+        break;
+    }
+}
+    
+    
+static const MemoryRegionOps mmio_ops = {
+    .read  = tiger4nsc_mem_read,
+    .write = tiger4nsc_mem_write,
+    .endianness = DEVICE_LITTLE_ENDIAN, //DEVICE_NATIVE_ENDIAN
+    .valid = {
+        .min_access_size = 4,
+        .max_access_size = 4
+    }
+};
+    
+static void tiger4nsc_reset(DeviceState *ds)
+{
+    Tiger4nscState *s = TIGER4NSC(SYS_BUS_DEVICE(ds));
+/*    Error *local_errp = NULL;
+
+    s->flash = DEVICE(object_property_get_link(OBJECT(s),
+                                               "flash",
+                                               &local_errp));
+    if (local_errp) {
+        fprintf(stderr, "ftnandc021: Unable to get flash link\n");
+        abort();
+    }
+    */
+// not sure that those number are valid for every device
+    s->spare_size = SPARE_SIZE; //in bytes
+
+    s->page_size = PAGE_SIZE; //in bytes
+    s->page_num_per_block = 128 * BIT_PER_FLASH_CELL;
+    //s->page_num_per_lun = (s->page_num_per_block * s->block_num_per_lun);
+    
+    s->block_size = (s->page_size * s->page_num_per_block);
+    s->block_num_per_lun = (BLOCK_NUM_PER_LUN / BIT_PER_FLASH_CELL);
+
+    s->lun_num_per_die = LUN_NUM_PER_DIE;
+    
+    s->block_num_per_die = (s->block_num_per_lun * s->lun_num_per_die);
+    s->block_num_per_channel = (s->block_num_per_die * s->ways);
+    
+    s->total_size = (s->block_num_per_channel * s->block_size);
+    
+    s->disk_size = (s->block_num_per_channel * 
+                    ((s->page_size + s->spare_size) * s->page_num_per_block) ); 
+
+    qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_reset: object at %lx size: %ld MB (%ld MB)\n",
+                (unsigned long)(void*)ds, (s->total_size >> 20), (s->disk_size >> 20) );   
+    qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_reset: page_num_per_block: %ld block_num_per_lun:%ld block_num_per_die:%ld block_num_per_channel:%ld \n",
+                s->page_num_per_block, s->block_num_per_lun, s->block_num_per_die, s->block_num_per_channel);   
+
+    s->cmdSelect = 0;
+    s->rowAddress = 0;
+    s->userData = 0;
+    s->dataAddress = 0;
+    s->spareAddress = 0;
+    s->errorCountAddress = 0;
+    s->completionAddress = 0;
+    s->waySelection = 0;
+    s->channelBusy = 0; //one controller is one channel
+    s->readyBusy = ~0; //one controller has multiple ways
+    
+    /* We can assume our GPIO outputs have been wired up now */
+//    qemu_set_irq(s->req, 0);
+    QTAILQ_INIT(&s->req_list);
+}
+
+static void tiger4nsc_realize(DeviceState *dev, Error **errp)
+{
+    Error *local_err =NULL;
+    Tiger4nscState *s = TIGER4NSC(dev);
+
+    sysbus_init_mmio(s->sbd, &s->mmio);
+//    sysbus_init_irq(sbd, &s->irq);
+    sysbus_mmio_map(s->sbd, 0, s->physical_address);   
+
+    /*
+    qdev_init_gpio_in(&sbd->qdev, ftnandc021_handle_ack, 1);
+    qdev_init_gpio_out(&sbd->qdev, &s->req, 1);
+    */
+    
+    qemu_log_mask(LOG_TRACE,
+                "tiger4nsc_realize: s %lx phys 0x%lx ways %d\n",
+                (unsigned long) s, (unsigned long)s->physical_address, (unsigned int) s->ways );   
+    
+    blkconf_apply_backend_options(&s->conf, blk_is_read_only(s->conf.blk),
+                                  false, &local_err);
+    if (local_err) {
+        error_report_err(local_err);
+    }
+
+}
+
+static const VMStateDescription vmstate_tiger4nsc = {
+    .name = TYPE_TIGER4NSC,
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .minimum_version_id_old = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_UINT32(cmdSelect, Tiger4nscState),
+        VMSTATE_UINT32(rowAddress, Tiger4nscState),
+        VMSTATE_UINT32(userData, Tiger4nscState),
+        VMSTATE_UINT32(dataAddress, Tiger4nscState),
+        VMSTATE_UINT32(spareAddress, Tiger4nscState),
+        VMSTATE_UINT32(errorCountAddress, Tiger4nscState),
+        VMSTATE_UINT32(completionAddress, Tiger4nscState),
+        VMSTATE_UINT32(waySelection, Tiger4nscState),
+        VMSTATE_UINT32(channelBusy, Tiger4nscState),
+        VMSTATE_UINT32(readyBusy, Tiger4nscState),
+        VMSTATE_END_OF_LIST()
+    }
+};    
+
+static void tiger4nsc_instance_init(Object *obj)
+{
+    Tiger4nscState *s = TIGER4NSC(obj);
+/* THIS IS TO LINK WITH THE FLASH DEVICES -- WE DON'T USE THIS FOR NOW
+    object_property_add_link(obj,
+                             "flash",
+                             TYPE_DEVICE,
+                             (Object **) &s->flash,
+                             NULL);
+                             */
+
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+    s->sbd =sbd;
+    
+    memory_region_init_io(&s->mmio,
+                          obj,
+                          &mmio_ops,
+                          s,
+                          TYPE_TIGER4NSC,
+                          V2Fmmio_SIZE);
+}
+    
+static Property tiger4nsc_properties[] = {
+    DEFINE_BLOCK_PROPERTIES(Tiger4nscState, conf),        
+    DEFINE_PROP_UINT8("ways", Tiger4nscState, ways, WAY_NUM),
+    DEFINE_PROP_UINT64("phys", Tiger4nscState, physical_address, V2Fmmio_ADDR),
+/*    DEFINE_PROP_STRING("serial", NvmeCtrl, serial),
+    DEFINE_PROP_DRIVE("drive", Tiger4nscState, blk), */
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void tiger4nsc_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->vmsd    = &vmstate_tiger4nsc;
+    dc->reset   = tiger4nsc_reset;
+    dc->realize = tiger4nsc_realize;
+    dc->props = tiger4nsc_properties;
+    dc->hotpluggable = true;
+    dc->user_creatable = true;
+    //dc->no_user = 1;
+}
+
+static const TypeInfo tiger4nsc_info = {
+    .name          = TYPE_TIGER4NSC,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(Tiger4nscState),
+    .instance_init = tiger4nsc_instance_init,
+    .class_init    = tiger4nsc_class_init,
+};
+
+static void tiger4nsc_register_types(void)
+{
+    type_register_static(&tiger4nsc_info);
+}
+
+type_init(tiger4nsc_register_types)
diff --git a/hw/arm/xilinx_zynq.c b/hw/arm/xilinx_zynq.c
index 3985356..d85cfba 100644
--- a/hw/arm/xilinx_zynq.c
+++ b/hw/arm/xilinx_zynq.c
@@ -171,7 +171,7 @@ static void zynq_init(MachineState *machine)
     BlockBackend *blk;
     qemu_irq pic[64];
     int n;
-
+    
     if (!cpu_model) {
         cpu_model = "cortex-a9";
     }
@@ -198,7 +198,8 @@ static void zynq_init(MachineState *machine)
         ram_size = 0x80000000;
     }
 
-    /* DDR remapped to address zero.  */
+    /* In our system DDR maps to 0x10000000*/ /* DDR remapped to address zero.  */
+        ram_size = 0x40000000;
     memory_region_allocate_system_memory(ext_ram, NULL, "zynq.ext_ram",
                                          ram_size);
     memory_region_add_subregion(address_space_mem, 0, ext_ram);
@@ -224,7 +225,8 @@ static void zynq_init(MachineState *machine)
     sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xF8000000);
 
     dev = qdev_create(NULL, "a9mpcore_priv");
-    qdev_prop_set_uint32(dev, "num-cpu", 1);
+    //qdev_prop_set_uint32(dev, "num-cpu", 1);
+    qdev_prop_set_uint32(dev, "num-cpu", 2);
     qdev_init_nofail(dev);
     busdev = SYS_BUS_DEVICE(dev);
     sysbus_mmio_map(busdev, 0, MPCORE_PERIPHBASE);
@@ -305,12 +307,26 @@ static void zynq_init(MachineState *machine)
     busdev = SYS_BUS_DEVICE(dev);
     sysbus_connect_irq(busdev, 0, pic[40 - IRQ_OFFSET]);
     sysbus_mmio_map(busdev, 0, 0xF8007000);
-
+/*
+// tiger4nsc module     
+    dev = qdev_create(NULL, "tiger4nsc");
+    qdev_init_nofail(dev);
+    busdev = SYS_BUS_DEVICE(dev);
+    //sysbus_connect_irq(busdev, 0, pic[40 - IRQ_OFFSET]);
+    sysbus_mmio_map(busdev, 0, 0x43c00000);
+    
+    dev = qdev_create(NULL, "tiger4nsc");
+    qdev_init_nofail(dev);
+    busdev = SYS_BUS_DEVICE(dev);
+    //sysbus_connect_irq(busdev, 0, pic[40 - IRQ_OFFSET]);
+    sysbus_mmio_map(busdev, 0, 0x43c10000);   
+*/    
+    
     zynq_binfo.ram_size = ram_size;
     zynq_binfo.kernel_filename = kernel_filename;
     zynq_binfo.kernel_cmdline = kernel_cmdline;
     zynq_binfo.initrd_filename = initrd_filename;
-    zynq_binfo.nb_cpus = 1;
+    zynq_binfo.nb_cpus = 2;
     zynq_binfo.board_id = 0xd32;
     zynq_binfo.loader_start = 0;
     zynq_binfo.board_setup_addr = BOARD_SETUP_ADDR;
@@ -323,8 +339,9 @@ static void zynq_machine_init(MachineClass *mc)
 {
     mc->desc = "Xilinx Zynq Platform Baseboard for Cortex-A9";
     mc->init = zynq_init;
-    mc->max_cpus = 1;
+    mc->max_cpus = 2;
     mc->no_sdcard = 1;
+    mc->has_dynamic_sysbus = true;
 }
 
 DEFINE_MACHINE("xilinx-zynq-a9", zynq_machine_init)
diff --git a/hw/block/nvme.c b/hw/block/nvme.c
index 6071dc1..ec0c949 100644
--- a/hw/block/nvme.c
+++ b/hw/block/nvme.c
@@ -102,15 +102,19 @@ static uint16_t nvme_map_prp(QEMUSGList *qsg, QEMUIOVector *iov, uint64_t prp1,
 
     if (!prp1) {
         return NVME_INVALID_FIELD | NVME_DNR;
-    } else if (n->cmbsz && prp1 >= n->ctrl_mem.addr &&
+// if requested prp1 address belongs to ctrl_mem USE qemu_iovec        
+    } else if (n->cmbsz &&
+               prp1 >= n->ctrl_mem.addr &&
                prp1 < n->ctrl_mem.addr + int128_get64(n->ctrl_mem.size)) {
         qsg->nsg = 0;
         qemu_iovec_init(iov, num_prps);
         qemu_iovec_add(iov, (void *)&n->cmbuf[prp1 - n->ctrl_mem.addr], trans_len);
+// othersiwe use pci_dma_sglist    
     } else {
         pci_dma_sglist_init(qsg, &n->parent_obj, num_prps);
         qemu_sglist_add(qsg, prp1, trans_len);
     }
+    
     len -= trans_len;
     if (len) {
         if (!prp2) {
@@ -1117,4 +1121,4 @@ static void nvme_register_types(void)
     type_register_static(&nvme_info);
 }
 
-type_init(nvme_register_types)
+type_init(nvme_register_types);
diff --git a/hw/char/cadence_uart.c b/hw/char/cadence_uart.c
index 4a2c124..7e1cd0d 100644
--- a/hw/char/cadence_uart.c
+++ b/hw/char/cadence_uart.c
@@ -29,6 +29,7 @@
 #include "qemu/log.h"
 #include "hw/char/cadence_uart.h"
 
+//#define CADENCE_UART_ERR_DEBUG
 #ifdef CADENCE_UART_ERR_DEBUG
 #define DB_PRINT(...) do { \
     fprintf(stderr,  ": %s: ", __func__); \
@@ -328,7 +329,7 @@ static void uart_write_tx_fifo(CadenceUARTState *s, const uint8_t *buf,
 
     memcpy(s->tx_fifo + s->tx_count, buf, size);
     s->tx_count += size;
-
+    
     cadence_uart_xmit(NULL, G_IO_OUT, s);
 }
 
@@ -382,7 +383,8 @@ static void uart_write(void *opaque, hwaddr offset,
 {
     CadenceUARTState *s = opaque;
 
-    DB_PRINT(" offset:%x data:%08x\n", (unsigned)offset, (unsigned)value);
+    DB_PRINT(" offset:%x data:%08x %d\n", (unsigned)offset, (unsigned)value,
+             (int)(s->r[R_MR] & UART_MR_CHMODE));
     offset >>= 2;
     if (offset >= CADENCE_UART_R_MAX) {
         return;
@@ -449,7 +451,8 @@ static uint64_t uart_read(void *opaque, hwaddr offset,
        c = s->r[offset];
     }
 
-    DB_PRINT(" offset:%x data:%08x\n", (unsigned)(offset << 2), (unsigned)c);
+    DB_PRINT(" offset:%x data:%08x (enable %x)\n", (unsigned)(offset << 2), (unsigned)c,
+             (unsigned int)(s->r[R_CR] & UART_CR_RX_DIS) || !(s->r[R_CR] & UART_CR_RX_EN));
     return c;
 }
 
